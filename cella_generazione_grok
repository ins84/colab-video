# ============================================
# CELLA 4: GENERAZIONE VIDEO - GROK (Space 44998)
# ============================================

from google.colab import drive
try:
    drive.mount('/content/drive')
except:
    print("Drive gi√† montato")

import pandas as pd
from playwright.async_api import async_playwright
import asyncio
import json
from pathlib import Path
from collections import defaultdict

MODEL = "grok"
BATCH_SIZE = 2
PAUSE_BETWEEN_PROMPTS = 20
MAX_DOWNLOAD_RETRIES = 2
MAX_GENERATION_WAIT = 500
DOWNLOAD_FOLDER_NAME = "video_generati_grok"

DURATION = "6s"
ASPECT_RATIO = "3:2"
RESOLUTION = "1080P"

async def automate_digen_grok_batch():
    BASE_URL = "https://digen.ai/en/space/44998"
    print(f"üé¨ Modalit√†: {MODEL.upper()} - Space 44998")
    print(f"‚öôÔ∏è Configurazione: {DURATION}, {ASPECT_RATIO}, {RESOLUTION}\n")

    print("üìÇ Lettura file Excel...")
    df = pd.read_excel('prompts.xlsx')
    total_prompts = len(df)
    print(f"‚úÖ Trovati {total_prompts} prompt\n")

    download_folder = Path(f"/content/drive/MyDrive/{DOWNLOAD_FOLDER_NAME}")
    download_folder.mkdir(exist_ok=True, parents=True)
    print(f"üìÅ Cartella download: {download_folder}\n")

    cookies_file = Path("digen_cookies.json")
    tracking_file = Path(f"video_tracking_{MODEL}.json")
    failed_file = Path(f"failed_prompts_{MODEL}.json")

    if tracking_file.exists():
        with open(tracking_file, 'r') as f:
            completed_prompts = set(json.load(f))
    else:
        completed_prompts = set()

    if failed_file.exists():
        with open(failed_file, 'r') as f:
            failed_prompts = json.load(f)
    else:
        failed_prompts = {}

    async def close_any_dialogs(page):
        try:
            await page.keyboard.press('Escape')
            await asyncio.sleep(0.5)
            overlay = page.locator('[data-slot="dialog-overlay"][data-state="open"]')
            if await overlay.count() > 0:
                await page.keyboard.press('Escape')
                await asyncio.sleep(1)
            await page.wait_for_selector('[data-slot="dialog-overlay"][data-state="open"]', state='hidden', timeout=5000)
        except:
            pass

    async def select_grok_model(page):
        """üéØ Clicca su bottone modello e seleziona 'Grok Video' dal menu popup"""
        try:
            print(f"   üéØ Seleziono modello Grok...")
            await close_any_dialogs(page)
            await asyncio.sleep(2)
            
            # üîç Cerca il bottone del modello attuale (es. RM2.6)
            all_buttons = await page.locator('button:visible').all()
            
            model_button = None
            for btn in all_buttons:
                try:
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text_clean = text.strip()
                    box = await btn.bounding_box()
                    
                    if not box:
                        continue
                    
                    # Zona controlli: y > 900, y < 1100
                    if 900 < box['y'] < 1100:
                        if 3 <= len(text_clean) <= 10 and any(c.isalpha() for c in text_clean):
                            if text_clean.lower() not in ['auto', 'create']:
                                if any(c.isdigit() for c in text_clean) or text_clean.isalpha():
                                    model_button = btn
                                    print(f"   ‚úÖ Trovato bottone modello: '{text_clean}' @ pos:({int(box['x'])},{int(box['y'])})")
                                    break
                except:
                    continue
            
            if not model_button:
                print(f"   ‚ö†Ô∏è Bottone modello non trovato")
                return False
            
            # Clicca per aprire il menu popup
            print(f"   üìÇ Apro menu modelli...")
            await model_button.click()
            await asyncio.sleep(3)
            
            # üéØ STRATEGIA: Cerca PRIMA "Grok Video" esatto, poi fallback su "Grok"
            print(f"   üîé Cerco 'Grok Video' nel menu popup...")
            
            candidates = []
            
            # Cerca in vari tipi di elementi
            selectors = [
                'button:visible',
                '[role="menuitem"]:visible', 
                '[role="option"]:visible',
                'div:visible',
                'span:visible',
                'li:visible',
                'a:visible'
            ]
            
            for selector in selectors:
                try:
                    elements = await page.locator(selector).all()
                    
                    for elem in elements:
                        try:
                            text = await elem.text_content()
                            if not text:
                                continue
                            
                            text_clean = text.strip()
                            text_lower = text_clean.lower()
                            
                            # Cerca "grok" nel testo
                            if 'grok' not in text_lower:
                                continue
                            
                            # Verifica che sia visibile
                            box = await elem.bounding_box()
                            if not box:
                                continue
                            
                            # Filtra solo elementi con testo corto/medio
                            if 3 <= len(text_clean) <= 50:
                                # üéØ Priorit√†: "Grok Video" ha priorit√† massima
                                priority = 0
                                if 'grok video' in text_lower:
                                    priority = 1  # Massima priorit√†
                                elif text_lower == 'grok':
                                    priority = 2  # Bassa priorit√† (potrebbe essere sidebar)
                                else:
                                    priority = 3  # Altri match (es. "Grok VideoAudio")
                                
                                candidates.append((elem, text_clean, priority, len(text_clean), box['width'] * box['height']))
                        except:
                            continue
                except:
                    continue
            
            if not candidates:
                print(f"   ‚ö†Ô∏è Nessun elemento con 'Grok' trovato nel menu")
                await page.keyboard.press('Escape')
                await asyncio.sleep(0.5)
                return False
            
            # üéØ Ordina per: 1) Priorit√† (Grok Video prima), 2) Testo pi√π corto, 3) Area pi√π piccola
            candidates.sort(key=lambda c: (c[2], c[3], c[4]))  # priority, text_len, area
            
            # Seleziona il migliore
            best_elem, best_text, best_priority, best_len, best_area = candidates[0]
            print(f"   ‚úÖ Seleziono: '{best_text}'")
            
            # Clicca
            try:
                await best_elem.click(timeout=5000)
                await asyncio.sleep(2)
                print(f"   ‚úÖ Modello Grok selezionato")
                return True
            except Exception as click_err:
                # Prova a cliccare su un elemento figlio cliccabile
                try:
                    print(f"   üîÑ Click diretto fallito, provo elemento figlio...")
                    clickable_child = best_elem.locator('button, [role="button"], a').first
                    if await clickable_child.count() > 0:
                        await clickable_child.click(timeout=5000)
                        await asyncio.sleep(2)
                        print(f"   ‚úÖ Modello Grok selezionato (via figlio)")
                        return True
                except:
                    pass
                
                print(f"   ‚ö†Ô∏è Impossibile cliccare: {str(click_err)[:50]}")
                await page.keyboard.press('Escape')
                await asyncio.sleep(0.5)
                return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore selezione Grok: {e}")
            return False

    async def set_duration(page, duration):
        try:
            print(f"   ‚è±Ô∏è Imposto durata {duration}...")
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            
            all_buttons = await page.locator('button:visible').all()
            
            for btn in all_buttons:
                try:
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text_clean = text.strip()
                    box = await btn.bounding_box()
                    
                    if not box or not (900 < box['y'] < 1100):
                        continue
                    
                    if 's' in text_clean.lower() and len(text_clean) < 5:
                        print(f"   üîç Trovato bottone durata: '{text_clean}'")
                        
                        if duration in text_clean:
                            print(f"   ‚úÖ Durata {duration} gi√† impostata")
                            return True
                        
                        print(f"   üìÇ Apro menu durata (attuale: {text_clean})...")
                        await btn.click()
                        await asyncio.sleep(3)
                        
                        all_visible = await page.locator('*:visible').all()
                        for elem in all_visible:
                            try:
                                text = await elem.text_content()
                                if text and duration == text.strip():
                                    await elem.click()
                                    await asyncio.sleep(1)
                                    print(f"   ‚úÖ Durata {duration} selezionata")
                                    return True
                            except:
                                continue
                        
                        await page.keyboard.press('Escape')
                        await asyncio.sleep(0.5)
                        break
                except:
                    continue
            
            print(f"   ‚ö†Ô∏è Durata non impostata")
            return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore durata: {str(e)[:80]}")
            return False

    async def set_aspect_ratio(page, ratio):
        try:
            print(f"   üìê Imposto aspect ratio {ratio}...")
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            
            all_buttons = await page.locator('button:visible').all()
            
            for btn in all_buttons:
                try:
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text_clean = text.strip()
                    box = await btn.bounding_box()
                    
                    if not box or not (900 < box['y'] < 1100):
                        continue
                    
                    if ':' in text_clean or 'auto' in text_clean.lower():
                        print(f"   üîç Trovato bottone aspect ratio: '{text_clean}'")
                        
                        if ratio in text_clean:
                            print(f"   ‚úÖ Aspect ratio {ratio} gi√† impostato")
                            return True
                        
                        print(f"   üìÇ Apro menu aspect ratio (attuale: {text_clean})...")
                        await btn.click()
                        await asyncio.sleep(3)
                        
                        all_visible = await page.locator('*:visible').all()
                        for elem in all_visible:
                            try:
                                text = await elem.text_content()
                                if text and ratio == text.strip():
                                    await elem.click()
                                    await asyncio.sleep(1)
                                    print(f"   ‚úÖ Aspect ratio {ratio} selezionato")
                                    return True
                            except:
                                continue
                        
                        await page.keyboard.press('Escape')
                        await asyncio.sleep(0.5)
                        break
                except:
                    continue
            
            print(f"   ‚ö†Ô∏è Aspect ratio non impostato")
            return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore aspect ratio: {str(e)[:80]}")
            return False

    async def set_resolution(page, resolution):
        """üéûÔ∏è Imposta risoluzione (es. 1080P)"""
        try:
            print(f"   üéûÔ∏è Imposto risoluzione {resolution}...")
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            
            all_buttons = await page.locator('button:visible').all()
            
            # Cerca il bottone della risoluzione
            for btn in all_buttons:
                try:
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text_clean = text.strip()
                    box = await btn.bounding_box()
                    
                    if not box or not (900 < box['y'] < 1100):
                        continue
                    
                    # Bottone risoluzione contiene "P" (es. 480P, 720P, 1080P)
                    if 'p' in text_clean.lower() and len(text_clean) < 8:
                        print(f"   üîç Trovato bottone risoluzione: '{text_clean}'")
                        
                        # Verifica se √® gi√† la risoluzione desiderata
                        if resolution.lower() in text_clean.lower():
                            print(f"   ‚úÖ Risoluzione {resolution} gi√† impostata")
                            return True
                        
                        # Apri menu e seleziona risoluzione
                        print(f"   üìÇ Apro menu risoluzione (attuale: {text_clean})...")
                        await btn.click()
                        await asyncio.sleep(3)
                        
                        # Cerca risoluzione desiderata nel menu
                        all_visible = await page.locator('*:visible').all()
                        for elem in all_visible:
                            try:
                                text = await elem.text_content()
                                if text and resolution.lower() in text.strip().lower():
                                    # Verifica lunghezza testo (es. "1080P" ha 5 char)
                                    if len(text.strip()) < 10:
                                        await elem.click()
                                        await asyncio.sleep(1)
                                        print(f"   ‚úÖ Risoluzione {resolution} selezionata")
                                        return True
                            except:
                                continue
                        
                        print(f"   ‚ö†Ô∏è {resolution} non trovato nel menu")
                        await page.keyboard.press('Escape')
                        await asyncio.sleep(0.5)
                        return False
                except:
                    continue
            
            print(f"   ‚ö†Ô∏è Bottone risoluzione non trovato")
            return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore risoluzione: {str(e)[:80]}")
            return False

    async def configure_generation_settings(page):
        print(f"   ‚öôÔ∏è Configurazione parametri generazione...")
        await close_any_dialogs(page)
        await select_grok_model(page)
        await set_duration(page, DURATION)
        await set_aspect_ratio(page, ASPECT_RATIO)
        await set_resolution(page, RESOLUTION)
        await close_any_dialogs(page)
        print(f"   ‚úÖ Configurazione completata\n")

    async def insert_prompt_multiline(page, prompt_text):
        try:
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            textarea = page.locator('textarea[maxlength="5000"]').first
            await textarea.wait_for(state='visible', timeout=10000)
            await textarea.click(force=True)
            await asyncio.sleep(0.5)
            await page.keyboard.press('Control+A')
            await page.keyboard.press('Backspace')
            await asyncio.sleep(0.3)
            await textarea.fill(prompt_text)
            await asyncio.sleep(0.5)
            return True
        except Exception as e:
            try:
                await page.keyboard.press('Escape')
                await asyncio.sleep(1)
                textarea = page.locator('textarea').first
                await textarea.click(force=True, timeout=5000)
                await asyncio.sleep(0.5)
                await page.keyboard.type(prompt_text, delay=10)
                await asyncio.sleep(0.5)
                return True
            except:
                return False

    async def click_generate_button(page):
        try:
            await close_any_dialogs(page)
            generate_selectors = [
                'button[class*="bg-light"][class*="font-medium"]:has(svg)',
                'button.bg-light:has(svg)',
                'button[data-slot="button"]:has(svg)'
            ]
            for selector in generate_selectors:
                try:
                    btn = page.locator(selector).last
                    if await btn.count() > 0 and await btn.is_visible():
                        await asyncio.sleep(2)
                        is_disabled = await btn.get_attribute('disabled')
                        if is_disabled is None:
                            print(f"   ‚úÖ Trovato bottone generate")
                            await btn.click()
                            return True
                except:
                    continue
            print(f"   üîÑ Uso shortcut Control+Enter")
            await page.keyboard.press('Control+Enter')
            return True
        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore click generate: {e}")
            return False

    async def is_button_enabled(btn):
        try:
            is_disabled = await btn.get_attribute('disabled')
            if is_disabled is not None:
                return False
            is_visible = await btn.is_visible()
            if not is_visible:
                return False
            box = await btn.bounding_box()
            if not box:
                return False
            return True
        except:
            return False

    async def wait_for_button_enabled(btn, timeout=30):
        start = asyncio.get_event_loop().time()
        while (asyncio.get_event_loop().time() - start) < timeout:
            if await is_button_enabled(btn):
                return True
            await asyncio.sleep(1)
        return False

    async def find_download_buttons_new_interface(page, check_enabled=True):
        try:
            await asyncio.sleep(2)
            download_selectors = [
                'button[data-slot="tooltip-trigger"]:has(svg)',
                'button.backdrop-blur-md:has(svg)',
                'button[class*="bg-light/10"]:has(svg)',
                'button.size-9:has(svg)'
            ]
            download_buttons = []
            for selector in download_selectors:
                try:
                    buttons = await page.locator(selector).all()
                    for btn in buttons:
                        try:
                            is_visible = await btn.is_visible()
                            if not is_visible:
                                continue
                            html = await btn.inner_html()
                            if 'M228,144v64a12,12,0,0,1-12,12H40' in html:
                                if check_enabled:
                                    if not await is_button_enabled(btn):
                                        continue
                                box = await btn.bounding_box()
                                if box:
                                    download_buttons.append((btn, box['x'], box['y']))
                        except Exception as e:
                            continue
                except Exception as e:
                    continue
            if not download_buttons:
                all_buttons = await page.locator('button:visible').all()
                for btn in all_buttons:
                    try:
                        box = await btn.bounding_box()
                        if not box:
                            continue
                        if 30 < box['width'] < 50 and 30 < box['height'] < 50:
                            html = await btn.inner_html()
                            if 'svg' in html.lower():
                                if check_enabled:
                                    if not await is_button_enabled(btn):
                                        continue
                                download_buttons.append((btn, box['x'], box['y']))
                    except:
                        continue
            download_buttons.sort(key=lambda b: b[2])
            if download_buttons:
                print(f"      ‚úÖ Trovati {len(download_buttons)} bottoni download")
            return download_buttons
        except Exception as e:
            print(f"      ‚ö†Ô∏è Errore ricerca bottoni: {e}")
            return []

    async def wait_for_videos_ready(page, expected_new, timeout=MAX_GENERATION_WAIT):
        print(f"   üéØ Nuovi video attesi: {expected_new}")
        print(f"   ‚è∞ Timeout massimo: {timeout}s (~{timeout//60} min)\n")
        start = asyncio.get_event_loop().time()
        max_buttons_seen = 0
        while (asyncio.get_event_loop().time() - start) < timeout:
            await asyncio.sleep(10)
            current_buttons = await find_download_buttons_new_interface(page, check_enabled=True)
            current_count = len(current_buttons)
            if current_count > max_buttons_seen:
                max_buttons_seen = current_count
                print(f"      üìä Nuovi bottoni rilevati: {current_count}")
            elapsed = int(asyncio.get_event_loop().time() - start)
            if current_count >= expected_new:
                print(f"\n   ‚úÖ {current_count} bottoni pronti = {expected_new} video generati!")
                return True
            if elapsed % 30 == 0 and elapsed > 0:
                print(f"      ‚è≥ {elapsed}s... bottoni: {current_count}/{expected_new}")
            if elapsed > 90 and current_count > 0:
                print(f"\n   ‚úÖ {current_count} bottoni dopo {elapsed}s, procedo!")
                return True
        print(f"\n   ‚ö†Ô∏è Timeout {timeout}s! Bottoni: {max_buttons_seen}/{expected_new}")
        if max_buttons_seen > 0:
            print(f"   ‚úÖ Trovati {max_buttons_seen} video, procedo!")
            return True
        else:
            print(f"   ‚ö†Ô∏è Nessun video pronto")
            return False

    async def download_from_position(page, file_name, download_folder, position):
        max_retries = MAX_DOWNLOAD_RETRIES
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    print(f"      üîÑ Tentativo {attempt + 1}/{max_retries}...")
                    await asyncio.sleep(10)
                print(f"      üîç Cerco bottoni download...")
                download_buttons = await find_download_buttons_new_interface(page, check_enabled=True)
                if not download_buttons:
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è Nessun bottone clickable, attendo...")
                        continue
                    return False, "Nessun bottone trovato dopo retry", None
                print(f"      ‚úÖ Trovati {len(download_buttons)} bottoni")
                if position >= len(download_buttons):
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è Posizione {position} non esiste, attendo...")
                        continue
                    return False, f"Posizione {position} non esiste", None
                download_btn, x, y = download_buttons[position]
                print(f"      üéØ Bottone posizione {position} a ({int(x)}, {int(y)})")
                print(f"      ‚è≥ Verifico che il bottone sia clickable...")
                if not await wait_for_button_enabled(download_btn, timeout=30):
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è Bottone non clickable, riprovo...")
                        continue
                    return False, "Bottone non clickable", None
                print(f"      üì• Clicco download...")
                async with page.expect_download(timeout=90000) as dl_info:
                    await download_btn.click()
                download = await dl_info.value
                ext = Path(download.suggested_filename).suffix or '.mp4'
                final_path = download_folder / f"{file_name}{ext}"
                print(f"      üíæ Salvo in Drive...")
                await download.save_as(str(final_path))
                size = final_path.stat().st_size
                if size < 10000:
                    final_path.unlink()
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è File corrotto, riprovo...")
                        continue
                    return False, "File corrotto", None
                size_mb = size / (1024 * 1024)
                return True, f"{size_mb:.1f} MB", final_path
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"      ‚ö†Ô∏è Errore: {str(e)[:50]}, riprovo...")
                    continue
                return False, f"Errore: {str(e)[:100]}", None
        return False, "Tutti i tentativi falliti", None

    def check_video_exists(file_name, download_folder):
        for ext in ['.mp4', '.webm', '.mov']:
            path = download_folder / f"{file_name}{ext}"
            if path.exists():
                size_mb = path.stat().st_size / (1024 * 1024)
                return True, path, size_mb
        return False, None, 0

    def save_tracking(completed, failed):
        with open(tracking_file, 'w') as f:
            json.dump(list(completed), f)
        with open(failed_file, 'w') as f:
            json.dump(failed, f, indent=2)

    print("üåê Avvio browser...")
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=['--no-sandbox', '--disable-dev-shm-usage']
        )
        context = await browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            accept_downloads=True,
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        )
        page = await context.new_page()
        page.on("dialog", lambda dialog: dialog.accept())

        try:
            if not cookies_file.exists():
                print("‚ùå File cookies non trovato! Esegui prima la CELLA 3")
                return

            print("üì• Carico sessione...")
            with open(cookies_file, 'r') as f:
                cookies = json.load(f)
            await context.add_cookies(cookies)

            print(f"üåê Navigo a DiGen.ai Space 44998...")
            await page.goto(BASE_URL, timeout=30000)
            await asyncio.sleep(3)

            await configure_generation_settings(page)

            print("‚úÖ Sessione valida e parametri configurati!\n")

            print(f"üé¨ INIZIO GENERAZIONE ({MODEL.upper()}) - Batch da {BATCH_SIZE}")
            print(f"‚è±Ô∏è Pausa tra prompt: {PAUSE_BETWEEN_PROMPTS}s")
            print(f"üîÑ Retry download: {MAX_DOWNLOAD_RETRIES} tentativi")
            print(f"‚è∞ Timeout generazione: {MAX_GENERATION_WAIT}s (~{MAX_GENERATION_WAIT//60} min)")
            print("="*60 + "\n")

            batch_num = 0
            for i in range(0, total_prompts, BATCH_SIZE):
                batch_num += 1
                batch = df.iloc[i:i+BATCH_SIZE]

                to_generate = []
                for idx, row in batch.iterrows():
                    file_name = str(row['NomeFile']).strip()

                    if file_name in completed_prompts:
                        continue

                    exists, path, size = check_video_exists(file_name, download_folder)
                    if exists:
                        print(f"   ‚è≠Ô∏è Skip {file_name}: gi√† presente ({size:.1f} MB)")
                        completed_prompts.add(file_name)
                        save_tracking(completed_prompts, failed_prompts)
                        continue

                    to_generate.append((idx, row))

                if not to_generate:
                    print(f"üì¶ BATCH {batch_num}: Tutti gi√† completati, skip\n")
                    continue

                print(f"üì¶ BATCH {batch_num}/{(total_prompts + BATCH_SIZE - 1) // BATCH_SIZE}")
                print(f"   Video da generare: {len(to_generate)}")

                print(f"   üîÑ Ricarico pagina...")
                await page.goto(BASE_URL, timeout=30000)
                await asyncio.sleep(2)
                await configure_generation_settings(page)
                await asyncio.sleep(2)

                generation_success = {}
                for gen_idx, (idx, row) in enumerate(to_generate):
                    prompt_text = str(row['Prompt']).strip()
                    file_name = str(row['NomeFile']).strip()

                    print(f"\n   üìù {gen_idx + 1}/{len(to_generate)}: {file_name}")

                    if not await insert_prompt_multiline(page, prompt_text):
                        print(f"   ‚ö†Ô∏è Errore inserimento, salto")
                        generation_success[file_name] = False
                        continue

                    print(f"   ‚úÖ Inserito")
                    print(f"   üöÄ Generate...")
                    
                    if await click_generate_button(page):
                        print(f"   ‚úÖ Inviato")
                        generation_success[file_name] = True
                    else:
                        print(f"   ‚ö†Ô∏è Errore invio")
                        generation_success[file_name] = False

                    if gen_idx < len(to_generate) - 1:
                        print(f"   ‚è∏Ô∏è Pausa {PAUSE_BETWEEN_PROMPTS}s...")
                        await asyncio.sleep(PAUSE_BETWEEN_PROMPTS)

                expected_videos = sum(1 for success in generation_success.values() if success)

                if expected_videos == 0:
                    print(f"\n‚ö†Ô∏è Nessun video da generare in questo batch\n")
                    continue

                print(f"\n‚è≥ Attendo che {expected_videos} video diventino pronti...")
                await wait_for_videos_ready(page, expected_videos)

                await asyncio.sleep(5)

                print(f"\nüì• Scarico {len(to_generate)} video...\n")

                successful_downloads = 0
                for download_idx in range(len(to_generate)):
                    idx, row = to_generate[download_idx]
                    file_name = str(row['NomeFile']).strip()

                    if not generation_success.get(file_name, False):
                        print(f"   ‚è≠Ô∏è {download_idx + 1}/{len(to_generate)}: {file_name} - Non generato, skip")
                        failed_prompts[file_name] = failed_prompts.get(file_name, 0) + 1
                        continue

                    position = download_idx

                    print(f"   {download_idx + 1}/{len(to_generate)}: {file_name} (pos: {position})")
                    success, msg, path = await download_from_position(
                        page, file_name, download_folder, position
                    )

                    if success:
                        print(f"      ‚úÖ {msg}\n")
                        completed_prompts.add(file_name)
                        failed_prompts.pop(file_name, None)
                        successful_downloads += 1
                    else:
                        print(f"      ‚ùå {msg}\n")
                        failed_prompts[file_name] = failed_prompts.get(file_name, 0) + 1

                    save_tracking(completed_prompts, failed_prompts)
                    await asyncio.sleep(3)

                print(f"‚úÖ BATCH {batch_num} COMPLETATO! ({successful_downloads}/{len(to_generate)} scaricati)\n")

                if i + BATCH_SIZE < total_prompts:
                    print("‚è∏Ô∏è Pausa 15s prima del prossimo batch...")
                    await asyncio.sleep(15)

            print("\n" + "="*60)
            print("üéâ GENERAZIONE COMPLETATA!")
            print("="*60)

            videos = list(download_folder.glob("*.mp4")) + list(download_folder.glob("*.webm"))
            total_mb = sum(v.stat().st_size for v in videos) / (1024 * 1024)

            print(f"\nüìä STATISTICHE FINALI:")
            print(f"   ‚úÖ Video scaricati: {len(videos)}/{total_prompts}")
            print(f"   üíæ Spazio totale: {total_mb:.1f} MB")
            print(f"   ‚ö° Batch processati: {batch_num}")
            print(f"   üé¨ Modello usato: {MODEL.upper()}")
            print(f"   ‚öôÔ∏è Configurazione: {DURATION}, {ASPECT_RATIO}, {RESOLUTION}")

            if failed_prompts:
                print(f"\n‚ö†Ô∏è VIDEO FALLITI: {len(failed_prompts)}")
                print("üìù Lista (salvata in failed_prompts.json):")
                for name, count in list(failed_prompts.items())[:10]:
                    print(f"   - {name}: {count} tentativi")
                if len(failed_prompts) > 10:
                    print(f"   ... e altri {len(failed_prompts) - 10}")
                print(f"\nüí° TIP: Riesegui lo script per riprovare i falliti")

            print(f"\nüìÅ Cartella: {download_folder}")
            print(f"üìÑ Tracking: {tracking_file}")
            print(f"‚ùå Fallimenti: {failed_file}\n")

        except Exception as e:
            print(f"\n‚ùå ERRORE CRITICO: {e}")
            import traceback
            traceback.print_exc()
        finally:
            await browser.close()

await automate_digen_grok_batch()
