# ============================================
# CELLA 4: GENERAZIONE VIDEO - GROK (Space 44998)
# ============================================

from google.colab import drive
try:
    drive.mount('/content/drive')
except:
    print("Drive gi√† montato")

import pandas as pd
from playwright.async_api import async_playwright
import asyncio
import json
from pathlib import Path
from collections import defaultdict

MODEL = "grok"
BATCH_SIZE = 2
PAUSE_BETWEEN_PROMPTS = 20
MAX_DOWNLOAD_RETRIES = 2
MAX_GENERATION_WAIT = 500
DOWNLOAD_FOLDER_NAME = "video_generati_grok"

DURATION = "6s"
ASPECT_RATIO = "3:2"
RESOLUTION = "1080P"

DEBUG_MODE = True

async def automate_digen_grok_batch():
    BASE_URL = "https://digen.ai/en/space/44998"
    print(f"üé¨ Modalit√†: {MODEL.upper()} - Space 44998")
    print(f"‚öôÔ∏è Configurazione: {DURATION}, {ASPECT_RATIO}, {RESOLUTION}\n")

    print("üìÇ Lettura file Excel...")
    df = pd.read_excel('prompts.xlsx')
    total_prompts = len(df)
    print(f"‚úÖ Trovati {total_prompts} prompt\n")

    download_folder = Path(f"/content/drive/MyDrive/{DOWNLOAD_FOLDER_NAME}")
    download_folder.mkdir(exist_ok=True, parents=True)
    print(f"üìÅ Cartella download: {download_folder}\n")

    cookies_file = Path("digen_cookies.json")
    tracking_file = Path(f"video_tracking_{MODEL}.json")
    failed_file = Path(f"failed_prompts_{MODEL}.json")

    if tracking_file.exists():
        with open(tracking_file, 'r') as f:
            completed_prompts = set(json.load(f))
    else:
        completed_prompts = set()

    if failed_file.exists():
        with open(failed_file, 'r') as f:
            failed_prompts = json.load(f)
    else:
        failed_prompts = {}

    async def close_any_dialogs(page):
        try:
            await page.keyboard.press('Escape')
            await asyncio.sleep(0.5)
            overlay = page.locator('[data-slot="dialog-overlay"][data-state="open"]')
            if await overlay.count() > 0:
                await page.keyboard.press('Escape')
                await asyncio.sleep(1)
            await page.wait_for_selector('[data-slot="dialog-overlay"][data-state="open"]', state='hidden', timeout=5000)
        except:
            pass

    async def select_grok_model(page):
        try:
            print(f"   üéØ Seleziono modello Grok...")
            await close_any_dialogs(page)
            await asyncio.sleep(3)
            
            # Cerca TUTTI i bottoni visibili
            all_buttons = await page.locator('button:visible').all()
            print(f"   üìä Totale bottoni visibili: {len(all_buttons)}")
            
            # üéØ Filtra bottoni nella BARRA CONTROLLI VIDEO (non sidebar)
            # I controlli video sono: x > 300px (dopo la sidebar), y < 150px (in alto)
            control_buttons = []
            for btn in all_buttons:
                try:
                    box = await btn.bounding_box()
                    # Controlli video: centro/destra della pagina, zona superiore
                    if box and box['x'] > 300 and box['y'] < 150:
                        control_buttons.append(btn)
                except:
                    continue
            
            print(f"   üîç Bottoni barra controlli (x>300, y<150): {len(control_buttons)}")
            
            if DEBUG_MODE and control_buttons:
                print(f"\n   üìù DEBUG: Bottoni nella barra controlli video:")
                for idx, btn in enumerate(control_buttons[:20]):
                    try:
                        text = await btn.text_content()
                        text_clean = text.strip() if text else "[no text]"
                        box = await btn.bounding_box()
                        x = int(box['x']) if box else 0
                        y = int(box['y']) if box else 0
                        w = int(box['width']) if box else 0
                        h = int(box['height']) if box else 0
                        print(f"      [{idx}] '{text_clean[:40]}' | pos:({x},{y}) size:{w}x{h}")
                    except Exception as e:
                        print(f"      [{idx}] ERROR: {str(e)[:40]}")
                print()
            
            # STRATEGIA 1: Cerca "Grok" nel testo
            print(f"   üîé Strategia 1: Cerca testo 'Grok'...")
            for idx, btn in enumerate(control_buttons):
                try:
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text_lower = text.strip().lower()
                    
                    if 'grok' in text_lower:
                        print(f"   ‚úÖ TROVATO Grok al bottone {idx}: '{text.strip()}'")
                        await btn.click()
                        await asyncio.sleep(2)
                        print(f"   ‚úÖ Modello Grok selezionato")
                        return True
                        
                except Exception as e:
                    continue
            
            # STRATEGIA 2: Cerca il PRIMO bottone con testo breve (non icona)
            print(f"   üîé Strategia 2: Primo bottone con testo (probabile modello)...")
            text_buttons = []
            for idx, btn in enumerate(control_buttons):
                try:
                    text = await btn.text_content()
                    if text:
                        text_clean = text.strip()
                        # Testo breve (3-15 caratteri), non solo emoji/simboli
                        if 3 <= len(text_clean) <= 15 and any(c.isalpha() for c in text_clean):
                            box = await btn.bounding_box()
                            text_buttons.append((idx, btn, text_clean, box['x'] if box else 0))
                            print(f"      Candidato [{idx}]: '{text_clean}'")
                except:
                    continue
            
            # Ordina per posizione X (da sinistra)
            text_buttons.sort(key=lambda x: x[3])
            
            # Prova il PRIMO bottone con testo (dovrebbe essere il modello)
            if text_buttons:
                idx, btn, txt, x = text_buttons[0]
                print(f"   ‚úÖ Seleziono primo bottone con testo: '{txt}' (indice {idx})")
                await btn.click()
                await asyncio.sleep(2)
                return True
            
            # STRATEGIA 3: Click sul primo bottone della barra controlli
            print(f"   üîé Strategia 3: Primo bottone barra controlli (fallback)...")
            if control_buttons:
                first_btn = control_buttons[0]
                text = await first_btn.text_content()
                print(f"   ‚ö†Ô∏è Uso primo bottone: '{text.strip() if text else '[no text]'}'")
                await first_btn.click()
                await asyncio.sleep(2)
                return True
            
            print(f"   ‚ö†Ô∏è Nessun bottone trovato nella barra controlli")
            return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore selezione Grok: {e}")
            return False

    async def set_aspect_ratio(page, ratio):
        try:
            print(f"   üìê Imposto aspect ratio {ratio}...")
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            
            aspect_buttons = await page.locator('button:has(svg:has(rect))').all()
            
            for btn in aspect_buttons:
                try:
                    if not await btn.is_visible():
                        continue
                    
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text = text.strip()
                    
                    if ratio in text:
                        print(f"   ‚úÖ Aspect ratio {ratio} gi√† impostato")
                        return True
                    
                    if ':' in text or 'auto' in text.lower():
                        print(f"   üìÇ Apro menu aspect ratio (attuale: {text})...")
                        await btn.click()
                        await asyncio.sleep(2)
                        
                        option = page.locator(f'button:has-text("{ratio}"), [role="menuitem"]:has-text("{ratio}")').first
                        
                        try:
                            await option.wait_for(state='visible', timeout=3000)
                            if await option.is_visible():
                                await option.click()
                                await asyncio.sleep(1)
                                print(f"   ‚úÖ Aspect ratio {ratio} selezionato")
                                return True
                        except:
                            await page.keyboard.press('Escape')
                            await asyncio.sleep(0.5)
                        
                        break
                except:
                    continue
            
            print(f"   ‚ö†Ô∏è Aspect ratio non impostato")
            return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore aspect ratio: {str(e)[:80]}")
            return False

    async def set_resolution(page, resolution):
        try:
            print(f"   üéûÔ∏è Verifico risoluzione {resolution}...")
            await close_any_dialogs(page)
            
            res_btn = page.locator(f'button:has-text("{resolution}")').first
            
            if await res_btn.count() > 0 and await res_btn.is_visible():
                print(f"   ‚úÖ Risoluzione {resolution} gi√† impostata")
                return True
            
            return False

        except Exception as e:
            return False

    async def set_duration(page, duration):
        try:
            print(f"   ‚è±Ô∏è Imposto durata {duration}...")
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            
            duration_buttons = await page.locator('button:has(svg:has(circle))').all()
            
            for btn in duration_buttons:
                try:
                    if not await btn.is_visible():
                        continue
                    
                    text = await btn.text_content()
                    if not text:
                        continue
                    
                    text = text.strip()
                    
                    if duration in text:
                        print(f"   ‚úÖ Durata {duration} gi√† impostata")
                        return True
                    
                    if 's' in text.lower() and len(text) < 10:
                        print(f"   üìÇ Apro menu durata (attuale: {text})...")
                        await btn.click()
                        await asyncio.sleep(2)
                        
                        option = page.locator(f'button:has-text("{duration}"), [role="menuitem"]:has-text("{duration}")').first
                        
                        try:
                            await option.wait_for(state='visible', timeout=3000)
                            if await option.is_visible():
                                await option.click()
                                await asyncio.sleep(1)
                                print(f"   ‚úÖ Durata {duration} selezionata")
                                return True
                        except:
                            await page.keyboard.press('Escape')
                            await asyncio.sleep(0.5)
                        
                        break
                except:
                    continue
            
            print(f"   ‚ö†Ô∏è Durata non impostata")
            return False

        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore durata: {str(e)[:80]}")
            return False

    async def configure_generation_settings(page):
        print(f"   ‚öôÔ∏è Configurazione parametri generazione...")
        await close_any_dialogs(page)
        await select_grok_model(page)
        await set_duration(page, DURATION)
        await set_aspect_ratio(page, ASPECT_RATIO)
        await set_resolution(page, RESOLUTION)
        await close_any_dialogs(page)
        print(f"   ‚úÖ Configurazione completata\n")

    async def insert_prompt_multiline(page, prompt_text):
        try:
            await close_any_dialogs(page)
            await asyncio.sleep(1)
            textarea = page.locator('textarea[maxlength="5000"]').first
            await textarea.wait_for(state='visible', timeout=10000)
            await textarea.click(force=True)
            await asyncio.sleep(0.5)
            await page.keyboard.press('Control+A')
            await page.keyboard.press('Backspace')
            await asyncio.sleep(0.3)
            await textarea.fill(prompt_text)
            await asyncio.sleep(0.5)
            return True
        except Exception as e:
            try:
                await page.keyboard.press('Escape')
                await asyncio.sleep(1)
                textarea = page.locator('textarea').first
                await textarea.click(force=True, timeout=5000)
                await asyncio.sleep(0.5)
                await page.keyboard.type(prompt_text, delay=10)
                await asyncio.sleep(0.5)
                return True
            except:
                return False

    async def click_generate_button(page):
        try:
            await close_any_dialogs(page)
            generate_selectors = [
                'button[class*="bg-light"][class*="font-medium"]:has(svg)',
                'button.bg-light:has(svg)',
                'button[data-slot="button"]:has(svg)'
            ]
            for selector in generate_selectors:
                try:
                    btn = page.locator(selector).last
                    if await btn.count() > 0 and await btn.is_visible():
                        await asyncio.sleep(2)
                        is_disabled = await btn.get_attribute('disabled')
                        if is_disabled is None:
                            print(f"   ‚úÖ Trovato bottone generate")
                            await btn.click()
                            return True
                except:
                    continue
            print(f"   üîÑ Uso shortcut Control+Enter")
            await page.keyboard.press('Control+Enter')
            return True
        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore click generate: {e}")
            return False

    async def is_button_enabled(btn):
        try:
            is_disabled = await btn.get_attribute('disabled')
            if is_disabled is not None:
                return False
            is_visible = await btn.is_visible()
            if not is_visible:
                return False
            box = await btn.bounding_box()
            if not box:
                return False
            return True
        except:
            return False

    async def wait_for_button_enabled(btn, timeout=30):
        start = asyncio.get_event_loop().time()
        while (asyncio.get_event_loop().time() - start) < timeout:
            if await is_button_enabled(btn):
                return True
            await asyncio.sleep(1)
        return False

    async def find_download_buttons_new_interface(page, check_enabled=True):
        try:
            await asyncio.sleep(2)
            download_selectors = [
                'button[data-slot="tooltip-trigger"]:has(svg)',
                'button.backdrop-blur-md:has(svg)',
                'button[class*="bg-light/10"]:has(svg)',
                'button.size-9:has(svg)'
            ]
            download_buttons = []
            for selector in download_selectors:
                try:
                    buttons = await page.locator(selector).all()
                    for btn in buttons:
                        try:
                            is_visible = await btn.is_visible()
                            if not is_visible:
                                continue
                            html = await btn.inner_html()
                            if 'M228,144v64a12,12,0,0,1-12,12H40' in html:
                                if check_enabled:
                                    if not await is_button_enabled(btn):
                                        continue
                                box = await btn.bounding_box()
                                if box:
                                    download_buttons.append((btn, box['x'], box['y']))
                        except Exception as e:
                            continue
                except Exception as e:
                    continue
            if not download_buttons:
                all_buttons = await page.locator('button:visible').all()
                for btn in all_buttons:
                    try:
                        box = await btn.bounding_box()
                        if not box:
                            continue
                        if 30 < box['width'] < 50 and 30 < box['height'] < 50:
                            html = await btn.inner_html()
                            if 'svg' in html.lower():
                                if check_enabled:
                                    if not await is_button_enabled(btn):
                                        continue
                                download_buttons.append((btn, box['x'], box['y']))
                    except:
                        continue
            download_buttons.sort(key=lambda b: b[2])
            if download_buttons:
                print(f"      ‚úÖ Trovati {len(download_buttons)} bottoni download")
            return download_buttons
        except Exception as e:
            print(f"      ‚ö†Ô∏è Errore ricerca bottoni: {e}")
            return []

    async def wait_for_videos_ready(page, expected_new, timeout=MAX_GENERATION_WAIT):
        print(f"   üéØ Nuovi video attesi: {expected_new}")
        print(f"   ‚è∞ Timeout massimo: {timeout}s (~{timeout//60} min)\n")
        start = asyncio.get_event_loop().time()
        max_buttons_seen = 0
        while (asyncio.get_event_loop().time() - start) < timeout:
            await asyncio.sleep(10)
            current_buttons = await find_download_buttons_new_interface(page, check_enabled=True)
            current_count = len(current_buttons)
            if current_count > max_buttons_seen:
                max_buttons_seen = current_count
                print(f"      üìä Nuovi bottoni rilevati: {current_count}")
            elapsed = int(asyncio.get_event_loop().time() - start)
            if current_count >= expected_new:
                print(f"\n   ‚úÖ {current_count} bottoni pronti = {expected_new} video generati!")
                return True
            if elapsed % 30 == 0 and elapsed > 0:
                print(f"      ‚è≥ {elapsed}s... bottoni: {current_count}/{expected_new}")
            if elapsed > 90 and current_count > 0:
                print(f"\n   ‚úÖ {current_count} bottoni dopo {elapsed}s, procedo!")
                return True
        print(f"\n   ‚ö†Ô∏è Timeout {timeout}s! Bottoni: {max_buttons_seen}/{expected_new}")
        if max_buttons_seen > 0:
            print(f"   ‚úÖ Trovati {max_buttons_seen} video, procedo!")
            return True
        else:
            print(f"   ‚ö†Ô∏è Nessun video pronto")
            return False

    async def download_from_position(page, file_name, download_folder, position):
        max_retries = MAX_DOWNLOAD_RETRIES
        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    print(f"      üîÑ Tentativo {attempt + 1}/{max_retries}...")
                    await asyncio.sleep(10)
                print(f"      üîç Cerco bottoni download...")
                download_buttons = await find_download_buttons_new_interface(page, check_enabled=True)
                if not download_buttons:
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è Nessun bottone clickable, attendo...")
                        continue
                    return False, "Nessun bottone trovato dopo retry", None
                print(f"      ‚úÖ Trovati {len(download_buttons)} bottoni")
                if position >= len(download_buttons):
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è Posizione {position} non esiste, attendo...")
                        continue
                    return False, f"Posizione {position} non esiste", None
                download_btn, x, y = download_buttons[position]
                print(f"      üéØ Bottone posizione {position} a ({int(x)}, {int(y)})")
                print(f"      ‚è≥ Verifico che il bottone sia clickable...")
                if not await wait_for_button_enabled(download_btn, timeout=30):
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è Bottone non clickable, riprovo...")
                        continue
                    return False, "Bottone non clickable", None
                print(f"      üì• Clicco download...")
                async with page.expect_download(timeout=90000) as dl_info:
                    await download_btn.click()
                download = await dl_info.value
                ext = Path(download.suggested_filename).suffix or '.mp4'
                final_path = download_folder / f"{file_name}{ext}"
                print(f"      üíæ Salvo in Drive...")
                await download.save_as(str(final_path))
                size = final_path.stat().st_size
                if size < 10000:
                    final_path.unlink()
                    if attempt < max_retries - 1:
                        print(f"      ‚ö†Ô∏è File corrotto, riprovo...")
                        continue
                    return False, "File corrotto", None
                size_mb = size / (1024 * 1024)
                return True, f"{size_mb:.1f} MB", final_path
            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"      ‚ö†Ô∏è Errore: {str(e)[:50]}, riprovo...")
                    continue
                return False, f"Errore: {str(e)[:100]}", None
        return False, "Tutti i tentativi falliti", None

    def check_video_exists(file_name, download_folder):
        for ext in ['.mp4', '.webm', '.mov']:
            path = download_folder / f"{file_name}{ext}"
            if path.exists():
                size_mb = path.stat().st_size / (1024 * 1024)
                return True, path, size_mb
        return False, None, 0

    def save_tracking(completed, failed):
        with open(tracking_file, 'w') as f:
            json.dump(list(completed), f)
        with open(failed_file, 'w') as f:
            json.dump(failed, f, indent=2)

    print("üåê Avvio browser...")
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=['--no-sandbox', '--disable-dev-shm-usage']
        )
        context = await browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            accept_downloads=True,
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        )
        page = await context.new_page()
        page.on("dialog", lambda dialog: dialog.accept())

        try:
            if not cookies_file.exists():
                print("‚ùå File cookies non trovato! Esegui prima la CELLA 3")
                return

            print("üì• Carico sessione...")
            with open(cookies_file, 'r') as f:
                cookies = json.load(f)
            await context.add_cookies(cookies)

            print(f"üåê Navigo a DiGen.ai Space 44998...")
            await page.goto(BASE_URL, timeout=30000)
            await asyncio.sleep(3)

            await configure_generation_settings(page)

            print("‚úÖ Sessione valida e parametri configurati!\n")

            print(f"üé¨ INIZIO GENERAZIONE ({MODEL.upper()}) - Batch da {BATCH_SIZE}")
            print(f"‚è±Ô∏è Pausa tra prompt: {PAUSE_BETWEEN_PROMPTS}s")
            print(f"üîÑ Retry download: {MAX_DOWNLOAD_RETRIES} tentativi")
            print(f"‚è∞ Timeout generazione: {MAX_GENERATION_WAIT}s (~{MAX_GENERATION_WAIT//60} min)")
            print("="*60 + "\n")

            batch_num = 0
            for i in range(0, total_prompts, BATCH_SIZE):
                batch_num += 1
                batch = df.iloc[i:i+BATCH_SIZE]

                to_generate = []
                for idx, row in batch.iterrows():
                    file_name = str(row['NomeFile']).strip()

                    if file_name in completed_prompts:
                        continue

                    exists, path, size = check_video_exists(file_name, download_folder)
                    if exists:
                        print(f"   ‚è≠Ô∏è Skip {file_name}: gi√† presente ({size:.1f} MB)")
                        completed_prompts.add(file_name)
                        save_tracking(completed_prompts, failed_prompts)
                        continue

                    to_generate.append((idx, row))

                if not to_generate:
                    print(f"üì¶ BATCH {batch_num}: Tutti gi√† completati, skip\n")
                    continue

                print(f"üì¶ BATCH {batch_num}/{(total_prompts + BATCH_SIZE - 1) // BATCH_SIZE}")
                print(f"   Video da generare: {len(to_generate)}")

                print(f"   üîÑ Ricarico pagina...")
                await page.goto(BASE_URL, timeout=30000)
                await asyncio.sleep(2)
                await configure_generation_settings(page)
                await asyncio.sleep(2)

                generation_success = {}
                for gen_idx, (idx, row) in enumerate(to_generate):
                    prompt_text = str(row['Prompt']).strip()
                    file_name = str(row['NomeFile']).strip()

                    print(f"\n   üìù {gen_idx + 1}/{len(to_generate)}: {file_name}")

                    if not await insert_prompt_multiline(page, prompt_text):
                        print(f"   ‚ö†Ô∏è Errore inserimento, salto")
                        generation_success[file_name] = False
                        continue

                    print(f"   ‚úÖ Inserito")
                    print(f"   üöÄ Generate...")
                    
                    if await click_generate_button(page):
                        print(f"   ‚úÖ Inviato")
                        generation_success[file_name] = True
                    else:
                        print(f"   ‚ö†Ô∏è Errore invio")
                        generation_success[file_name] = False

                    if gen_idx < len(to_generate) - 1:
                        print(f"   ‚è∏Ô∏è Pausa {PAUSE_BETWEEN_PROMPTS}s...")
                        await asyncio.sleep(PAUSE_BETWEEN_PROMPTS)

                expected_videos = sum(1 for success in generation_success.values() if success)

                if expected_videos == 0:
                    print(f"\n‚ö†Ô∏è Nessun video da generare in questo batch\n")
                    continue

                print(f"\n‚è≥ Attendo che {expected_videos} video diventino pronti...")
                await wait_for_videos_ready(page, expected_videos)

                await asyncio.sleep(5)

                print(f"\nüì• Scarico {len(to_generate)} video...\n")

                successful_downloads = 0
                for download_idx in range(len(to_generate)):
                    idx, row = to_generate[download_idx]
                    file_name = str(row['NomeFile']).strip()

                    if not generation_success.get(file_name, False):
                        print(f"   ‚è≠Ô∏è {download_idx + 1}/{len(to_generate)}: {file_name} - Non generato, skip")
                        failed_prompts[file_name] = failed_prompts.get(file_name, 0) + 1
                        continue

                    position = download_idx

                    print(f"   {download_idx + 1}/{len(to_generate)}: {file_name} (pos: {position})")
                    success, msg, path = await download_from_position(
                        page, file_name, download_folder, position
                    )

                    if success:
                        print(f"      ‚úÖ {msg}\n")
                        completed_prompts.add(file_name)
                        failed_prompts.pop(file_name, None)
                        successful_downloads += 1
                    else:
                        print(f"      ‚ùå {msg}\n")
                        failed_prompts[file_name] = failed_prompts.get(file_name, 0) + 1

                    save_tracking(completed_prompts, failed_prompts)
                    await asyncio.sleep(3)

                print(f"‚úÖ BATCH {batch_num} COMPLETATO! ({successful_downloads}/{len(to_generate)} scaricati)\n")

                if i + BATCH_SIZE < total_prompts:
                    print("‚è∏Ô∏è Pausa 15s prima del prossimo batch...")
                    await asyncio.sleep(15)

            print("\n" + "="*60)
            print("üéâ GENERAZIONE COMPLETATA!")
            print("="*60)

            videos = list(download_folder.glob("*.mp4")) + list(download_folder.glob("*.webm"))
            total_mb = sum(v.stat().st_size for v in videos) / (1024 * 1024)

            print(f"\nüìä STATISTICHE FINALI:")
            print(f"   ‚úÖ Video scaricati: {len(videos)}/{total_prompts}")
            print(f"   üíæ Spazio totale: {total_mb:.1f} MB")
            print(f"   ‚ö° Batch processati: {batch_num}")
            print(f"   üé¨ Modello usato: {MODEL.upper()}")
            print(f"   ‚öôÔ∏è Configurazione: {DURATION}, {ASPECT_RATIO}, {RESOLUTION}")

            if failed_prompts:
                print(f"\n‚ö†Ô∏è VIDEO FALLITI: {len(failed_prompts)}")
                print("üìù Lista (salvata in failed_prompts.json):")
                for name, count in list(failed_prompts.items())[:10]:
                    print(f"   - {name}: {count} tentativi")
                if len(failed_prompts) > 10:
                    print(f"   ... e altri {len(failed_prompts) - 10}")
                print(f"\nüí° TIP: Riesegui lo script per riprovare i falliti")

            print(f"\nüìÅ Cartella: {download_folder}")
            print(f"üìÑ Tracking: {tracking_file}")
            print(f"‚ùå Fallimenti: {failed_file}\n")

        except Exception as e:
            print(f"\n‚ùå ERRORE CRITICO: {e}")
            import traceback
            traceback.print_exc()
        finally:
            await browser.close()

await automate_digen_grok_batch()
