# ============================================
# CELLA 4: GENERAZIONE VIDEO - GROK (Space 44998)
# ============================================

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from playwright.async_api import async_playwright
import asyncio
import json
from pathlib import Path
from collections import defaultdict

MODEL = "grok"  # Modello fisso per questo script
BATCH_SIZE = 2
PAUSE_BETWEEN_PROMPTS = 20
MAX_DOWNLOAD_RETRIES = 2
MAX_GENERATION_WAIT = 500  # 8 minuti per generazioni lente
DOWNLOAD_FOLDER_NAME = "video_generati_grok"

# Configurazione generazione
DURATION = "6s"
ASPECT_RATIO = "3:2"
RESOLUTION = "1080P"

async def automate_digen_grok_batch():
    BASE_URL = "https://digen.ai/en/space/44998"
    print(f"ğŸ¬ ModalitÃ : {MODEL.upper()} - Space 44998")
    print(f"âš™ï¸ Configurazione: {DURATION}, {ASPECT_RATIO}, {RESOLUTION}\n")

    print("ğŸ“‚ Lettura file Excel...")
    df = pd.read_excel('prompts.xlsx')
    total_prompts = len(df)
    print(f"âœ… Trovati {total_prompts} prompt\n")

    download_folder = Path(f"/content/drive/MyDrive/{DOWNLOAD_FOLDER_NAME}")
    download_folder.mkdir(exist_ok=True, parents=True)
    print(f"ğŸ“ Cartella download: {download_folder}\n")

    cookies_file = Path("digen_cookies.json")
    tracking_file = Path(f"video_tracking_{MODEL}.json")
    failed_file = Path(f"failed_prompts_{MODEL}.json")

    if tracking_file.exists():
        with open(tracking_file, 'r') as f:
            completed_prompts = set(json.load(f))
    else:
        completed_prompts = set()

    if failed_file.exists():
        with open(failed_file, 'r') as f:
            failed_prompts = json.load(f)
    else:
        failed_prompts = {}

    # ============================================
    # FUNZIONI HELPER
    # ============================================

    async def select_grok_model(page):
        """Seleziona il modello Grok dalla nuova interfaccia"""
        try:
            print(f"   ğŸ¯ Seleziono modello Grok...")
            
            # Aspetta che la pagina sia caricata
            await asyncio.sleep(3)
            
            # Cerca il pulsante Grok usando vari selettori
            grok_selectors = [
                'button:has-text("Grok")',
                'button:has([class*="grok" i])',
                '[data-slot="popover-trigger"]:has-text("Grok")',
                'button:has(span:text-is("Grok"))',
                'button:has(svg) >> text=Grok'
            ]
            
            for selector in grok_selectors:
                try:
                    grok_btn = page.locator(selector).first
                    if await grok_btn.count() > 0:
                        # Verifica che il bottone sia visibile
                        if await grok_btn.is_visible():
                            print(f"   âœ… Trovato bottone Grok con selector: {selector}")
                            await grok_btn.click()
                            await asyncio.sleep(2)
                            print(f"   âœ… Modello Grok selezionato")
                            return True
                except Exception as e:
                    continue
            
            print(f"   âš ï¸ Bottone Grok non trovato con selettori standard")
            
            # Fallback: cerca tutti i bottoni con testo "Grok"
            all_buttons = await page.locator('button:visible').all()
            for btn in all_buttons:
                try:
                    text = await btn.inner_text()
                    if 'grok' in text.lower():
                        print(f"   âœ… Trovato bottone Grok tramite scansione")
                        await btn.click()
                        await asyncio.sleep(2)
                        print(f"   âœ… Modello Grok selezionato")
                        return True
                except:
                    continue
            
            print(f"   âš ï¸ Modello Grok non trovato, procedo comunque...")
            return False

        except Exception as e:
            print(f"   âš ï¸ Errore selezione Grok: {e}")
            return False

    async def set_aspect_ratio(page, ratio):
        """Imposta aspect ratio (es. 3:2)"""
        try:
            print(f"   ğŸ“ Imposto aspect ratio {ratio}...")
            
            # Cerca il bottone aspect ratio (quello con l'icona rettangolo)
            aspect_selectors = [
                f'button:has-text("{ratio}")',
                'button:has(svg:has(rect))',  # Icona rettangolo
                '[data-slot="popover-trigger"]:has-text("Auto")',
                'button:has-text("Auto")'
            ]
            
            # Prima clicca per aprire il menu
            for selector in aspect_selectors:
                try:
                    btn = page.locator(selector).first
                    if await btn.count() > 0 and await btn.is_visible():
                        print(f"   âœ… Trovato menu aspect ratio")
                        await btn.click()
                        await asyncio.sleep(1)
                        
                        # Ora cerca l'opzione 3:2 nel menu
                        ratio_option = page.locator(f'button:has-text("{ratio}"), [role="menuitem"]:has-text("{ratio}")').first
                        if await ratio_option.count() > 0:
                            await ratio_option.click()
                            await asyncio.sleep(1)
                            print(f"   âœ… Aspect ratio {ratio} selezionato")
                            return True
                        break
                except Exception as e:
                    continue
            
            print(f"   âš ï¸ Aspect ratio non impostato, uso default")
            return False

        except Exception as e:
            print(f"   âš ï¸ Errore impostazione aspect ratio: {e}")
            return False

    async def set_resolution(page, resolution):
        """Imposta risoluzione (es. 1080P)"""
        try:
            print(f"   ğŸï¸ Imposto risoluzione {resolution}...")
            
            # Cerca il bottone risoluzione
            res_selectors = [
                f'button:has-text("{resolution}")',
                '[data-slot="popover-trigger"]:has-text("1080P")',
                'button:text-matches("\\d+P", "i")'
            ]
            
            # Se il bottone mostra giÃ  1080P, Ã¨ giÃ  impostato
            for selector in res_selectors:
                try:
                    btn = page.locator(selector).first
                    if await btn.count() > 0 and await btn.is_visible():
                        text = await btn.inner_text()
                        if resolution in text:
                            print(f"   âœ… Risoluzione {resolution} giÃ  impostata")
                            return True
                        
                        # Altrimenti clicca per aprire menu
                        await btn.click()
                        await asyncio.sleep(1)
                        
                        # Cerca opzione nel menu
                        res_option = page.locator(f'button:has-text("{resolution}"), [role="menuitem"]:has-text("{resolution}")').first
                        if await res_option.count() > 0:
                            await res_option.click()
                            await asyncio.sleep(1)
                            print(f"   âœ… Risoluzione {resolution} selezionata")
                            return True
                        break
                except Exception as e:
                    continue
            
            print(f"   âš ï¸ Risoluzione non impostata, uso default")
            return False

        except Exception as e:
            print(f"   âš ï¸ Errore impostazione risoluzione: {e}")
            return False

    async def set_duration(page, duration):
        """Imposta durata (es. 6s)"""
        try:
            print(f"   â±ï¸ Verifico durata {duration}...")
            
            # Cerca il bottone durata (con icona orologio)
            duration_selectors = [
                f'button:has-text("{duration}")',
                'button:has(svg:has(circle))',  # Icona orologio
                '[data-slot="popover-trigger"]:has-text("s")'
            ]
            
            for selector in duration_selectors:
                try:
                    btn = page.locator(selector).first
                    if await btn.count() > 0 and await btn.is_visible():
                        text = await btn.inner_text()
                        if duration in text:
                            print(f"   âœ… Durata {duration} giÃ  impostata")
                            return True
                        
                        # Clicca per aprire menu
                        await btn.click()
                        await asyncio.sleep(1)
                        
                        # Cerca opzione nel menu
                        dur_option = page.locator(f'button:has-text("{duration}"), [role="menuitem"]:has-text("{duration}")').first
                        if await dur_option.count() > 0:
                            await dur_option.click()
                            await asyncio.sleep(1)
                            print(f"   âœ… Durata {duration} selezionata")
                            return True
                        break
                except Exception as e:
                    continue
            
            print(f"   âš ï¸ Durata non impostata, uso default")
            return False

        except Exception as e:
            print(f"   âš ï¸ Errore impostazione durata: {e}")
            return False

    async def configure_generation_settings(page):
        """Configura tutti i parametri di generazione"""
        print(f"   âš™ï¸ Configurazione parametri generazione...")
        
        await select_grok_model(page)
        await set_duration(page, DURATION)
        await set_aspect_ratio(page, ASPECT_RATIO)
        await set_resolution(page, RESOLUTION)
        
        print(f"   âœ… Configurazione completata\n")

    async def insert_prompt_multiline(page, prompt_text):
        try:
            # Cerca il textarea nella nuova interfaccia
            textarea = page.locator('textarea[placeholder*="Describe"], textarea[maxlength="5000"]').first
            
            if await textarea.count() == 0:
                textarea = page.locator('textarea').first
            
            await textarea.click()
            await asyncio.sleep(0.3)
            await page.keyboard.press('Control+A')
            await page.keyboard.press('Backspace')
            await asyncio.sleep(0.3)
            await textarea.fill(prompt_text)
            await asyncio.sleep(0.5)
            return True
        except Exception as e:
            print(f"      âš ï¸ Errore inserimento: {e}")
            return False

    async def click_generate_button(page):
        """Clicca il bottone di generazione (quello con l'icona stella)"""
        try:
            # Cerca il bottone generate - ha l'icona stella e bg-light
            generate_selectors = [
                'button[data-slot="button"]:has(svg)',
                'button.bg-light:has(svg)',
                'button[class*="bg-light"]:has(svg:has(path))',
                'button:has(svg) >> nth=-1'  # Ultimo bottone con svg (di solito Ã¨ il generate)
            ]
            
            for selector in generate_selectors:
                try:
                    btn = page.locator(selector).first
                    if await btn.count() > 0 and await btn.is_visible():
                        # Aspetta che sia enabled
                        await asyncio.sleep(2)
                        
                        # Verifica che non sia disabled
                        is_disabled = await btn.get_attribute('disabled')
                        if is_disabled is None:
                            print(f"   âœ… Trovato bottone generate")
                            await btn.click()
                            return True
                except:
                    continue
            
            # Fallback: premi Control+Enter
            print(f"   ğŸ”„ Uso shortcut Control+Enter")
            await page.keyboard.press('Control+Enter')
            return True

        except Exception as e:
            print(f"   âš ï¸ Errore click generate: {e}")
            return False

    async def is_button_enabled(btn):
        try:
            is_disabled = await btn.get_attribute('disabled')
            if is_disabled is not None:
                return False

            is_visible = await btn.is_visible()
            if not is_visible:
                return False

            box = await btn.bounding_box()
            if not box:
                return False

            return True
        except:
            return False

    async def wait_for_button_enabled(btn, timeout=30):
        start = asyncio.get_event_loop().time()

        while (asyncio.get_event_loop().time() - start) < timeout:
            if await is_button_enabled(btn):
                return True
            await asyncio.sleep(1)

        return False

    async def find_download_buttons_new_interface(page, check_enabled=True):
        """ğŸ†• Cerca bottoni download nella NUOVA interfaccia (overlay sui video)"""
        try:
            await asyncio.sleep(2)
            
            # Cerca bottoni con le caratteristiche specifiche del nuovo design
            download_selectors = [
                'button[data-slot="tooltip-trigger"]:has(svg)',  # Principale
                'button.backdrop-blur-md:has(svg)',  # Con backdrop blur
                'button[class*="bg-light/10"]:has(svg)',  # Con bg-light/10
                'button.size-9:has(svg)',  # Size 9
                'button:has(svg[viewBox="0 0 256 256"])'  # SVG specifica
            ]
            
            download_buttons = []
            
            for selector in download_selectors:
                try:
                    buttons = await page.locator(selector).all()
                    
                    for btn in buttons:
                        try:
                            is_visible = await btn.is_visible()
                            if not is_visible:
                                continue
                            
                            # Verifica che abbia l'icona download (freccia giÃ¹)
                            html = await btn.inner_html()
                            
                            # Cerca path SVG con pattern di freccia download
                            if 'M228,144v64a12,12,0,0,1-12,12H40' in html or \
                               'path' in html.lower() and 'download' in html.lower():
                                
                                if check_enabled:
                                    if not await is_button_enabled(btn):
                                        continue
                                
                                box = await btn.bounding_box()
                                if box:
                                    download_buttons.append((btn, box['x'], box['y']))
                                    
                        except Exception as e:
                            continue
                            
                except Exception as e:
                    continue
            
            # Se non trova con selettori specifici, cerca tutti i bottoni piccoli con SVG
            if not download_buttons:
                print(f"      ğŸ”„ Fallback: cerco tutti i bottoni con SVG...")
                all_buttons = await page.locator('button:visible').all()
                
                for btn in all_buttons:
                    try:
                        box = await btn.bounding_box()
                        if not box:
                            continue
                        
                        # Bottoni piccoli (circa 36x36)
                        if 30 < box['width'] < 50 and 30 < box['height'] < 50:
                            html = await btn.inner_html()
                            
                            # Ha SVG?
                            if 'svg' in html.lower():
                                if check_enabled:
                                    if not await is_button_enabled(btn):
                                        continue
                                
                                download_buttons.append((btn, box['x'], box['y']))
                    except:
                        continue
            
            # Ordina per posizione Y (dall'alto verso il basso)
            download_buttons.sort(key=lambda b: b[2])
            
            print(f"      âœ… Trovati {len(download_buttons)} bottoni download")
            return download_buttons

        except Exception as e:
            print(f"      âš ï¸ Errore ricerca bottoni: {e}")
            return []

    async def wait_for_videos_ready(page, expected_new, timeout=MAX_GENERATION_WAIT):
        """Attende che i nuovi video siano pronti monitorando i bottoni download"""
        print(f"   ğŸ¯ Nuovi video attesi: {expected_new}")
        print(f"   â° Timeout massimo: {timeout}s (~{timeout//60} min)\n")

        start = asyncio.get_event_loop().time()
        max_buttons_seen = 0

        while (asyncio.get_event_loop().time() - start) < timeout:
            await asyncio.sleep(10)

            current_buttons = await find_download_buttons_new_interface(page, check_enabled=True)
            current_count = len(current_buttons)
            
            if current_count > max_buttons_seen:
                max_buttons_seen = current_count
                print(f"      ğŸ“Š Nuovi bottoni rilevati: {current_count}")

            elapsed = int(asyncio.get_event_loop().time() - start)

            # Se abbiamo tutti i bottoni attesi
            if current_count >= expected_new:
                print(f"\n   âœ… {current_count} bottoni pronti = {expected_new} video generati!")
                return True

            # Log ogni 30s
            if elapsed % 30 == 0 and elapsed > 0:
                print(f"      â³ {elapsed}s... bottoni: {current_count}/{expected_new}")

            # Dopo 90s con bottoni disponibili, procedi
            if elapsed > 90 and current_count > 0:
                print(f"\n   âœ… {current_count} bottoni dopo {elapsed}s, procedo!")
                return True

        # Timeout
        print(f"\n   âš ï¸ Timeout {timeout}s! Bottoni: {max_buttons_seen}/{expected_new}")

        if max_buttons_seen > 0:
            print(f"   âœ… Trovati {max_buttons_seen} video, procedo!")
            return True
        else:
            print(f"   âš ï¸ Nessun video pronto")
            return False

    async def download_from_position(page, file_name, download_folder, position):
        """Scarica video dalla posizione specificata (0=piÃ¹ recente)"""
        max_retries = MAX_DOWNLOAD_RETRIES

        for attempt in range(max_retries):
            try:
                if attempt > 0:
                    print(f"      ğŸ”„ Tentativo {attempt + 1}/{max_retries}...")
                    await asyncio.sleep(10)

                print(f"      ğŸ” Cerco bottoni download...")
                download_buttons = await find_download_buttons_new_interface(page, check_enabled=True)

                if not download_buttons:
                    if attempt < max_retries - 1:
                        print(f"      âš ï¸ Nessun bottone clickable, attendo...")
                        continue
                    return False, "Nessun bottone trovato dopo retry", None

                print(f"      âœ… Trovati {len(download_buttons)} bottoni")

                if position >= len(download_buttons):
                    if attempt < max_retries - 1:
                        print(f"      âš ï¸ Posizione {position} non esiste, attendo...")
                        continue
                    return False, f"Posizione {position} non esiste (solo {len(download_buttons)} bottoni)", None

                download_btn, x, y = download_buttons[position]
                print(f"      ğŸ¯ Bottone posizione {position} a ({int(x)}, {int(y)})")

                print(f"      â³ Verifico che il bottone sia clickable...")
                if not await wait_for_button_enabled(download_btn, timeout=30):
                    if attempt < max_retries - 1:
                        print(f"      âš ï¸ Bottone non clickable, riprovo...")
                        continue
                    return False, "Bottone non clickable dopo 30s", None

                print(f"      ğŸ“¥ Clicco download...")
                async with page.expect_download(timeout=90000) as dl_info:
                    await download_btn.click()
                download = await dl_info.value

                ext = Path(download.suggested_filename).suffix or '.mp4'
                final_path = download_folder / f"{file_name}{ext}"

                print(f"      ğŸ’¾ Salvo in Drive...")
                await download.save_as(str(final_path))

                size = final_path.stat().st_size
                if size < 10000:
                    final_path.unlink()
                    if attempt < max_retries - 1:
                        print(f"      âš ï¸ File corrotto, riprovo...")
                        continue
                    return False, "File corrotto", None

                size_mb = size / (1024 * 1024)
                return True, f"{size_mb:.1f} MB", final_path

            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"      âš ï¸ Errore: {str(e)[:50]}, riprovo...")
                    continue
                return False, f"Errore: {str(e)[:100]}", None

        return False, "Tutti i tentativi falliti", None

    def check_video_exists(file_name, download_folder):
        for ext in ['.mp4', '.webm', '.mov']:
            path = download_folder / f"{file_name}{ext}"
            if path.exists():
                size_mb = path.stat().st_size / (1024 * 1024)
                return True, path, size_mb
        return False, None, 0

    def save_tracking(completed, failed):
        with open(tracking_file, 'w') as f:
            json.dump(list(completed), f)
        with open(failed_file, 'w') as f:
            json.dump(failed, f, indent=2)

    # ============================================
    # MAIN EXECUTION
    # ============================================

    print("ğŸŒ Avvio browser...")
    async with async_playwright() as p:
        browser = await p.chromium.launch(
            headless=True,
            args=['--no-sandbox', '--disable-dev-shm-usage']
        )
        context = await browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            accept_downloads=True,
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        )
        page = await context.new_page()
        page.on("dialog", lambda dialog: dialog.accept())

        try:
            if not cookies_file.exists():
                print("âŒ File cookies non trovato! Esegui prima la CELLA 3")
                return

            print("ğŸ“¥ Carico sessione...")
            with open(cookies_file, 'r') as f:
                cookies = json.load(f)
            await context.add_cookies(cookies)

            print(f"ğŸŒ Navigo a DiGen.ai Space 44998...")
            await page.goto(BASE_URL, timeout=30000)
            await asyncio.sleep(3)

            # Configura i parametri di generazione
            await configure_generation_settings(page)

            print("âœ… Sessione valida e parametri configurati!\n")

            print(f"ğŸ¬ INIZIO GENERAZIONE ({MODEL.upper()}) - Batch da {BATCH_SIZE}")
            print(f"â±ï¸ Pausa tra prompt: {PAUSE_BETWEEN_PROMPTS}s")
            print(f"ğŸ”„ Retry download: {MAX_DOWNLOAD_RETRIES} tentativi")
            print(f"â° Timeout generazione: {MAX_GENERATION_WAIT}s (~{MAX_GENERATION_WAIT//60} min)")
            print("="*60 + "\n")

            batch_num = 0
            for i in range(0, total_prompts, BATCH_SIZE):
                batch_num += 1
                batch = df.iloc[i:i+BATCH_SIZE]

                to_generate = []
                for idx, row in batch.iterrows():
                    file_name = str(row['NomeFile']).strip()

                    if file_name in completed_prompts:
                        continue

                    exists, path, size = check_video_exists(file_name, download_folder)
                    if exists:
                        print(f"   â­ï¸ Skip {file_name}: giÃ  presente ({size:.1f} MB)")
                        completed_prompts.add(file_name)
                        save_tracking(completed_prompts, failed_prompts)
                        continue

                    to_generate.append((idx, row))

                if not to_generate:
                    print(f"ğŸ“¦ BATCH {batch_num}: Tutti giÃ  completati, skip\n")
                    continue

                print(f"ğŸ“¦ BATCH {batch_num}/{(total_prompts + BATCH_SIZE - 1) // BATCH_SIZE}")
                print(f"   Video da generare: {len(to_generate)}")

                print(f"   ğŸ”„ Ricarico pagina...")
                await page.goto(BASE_URL, timeout=30000)
                await asyncio.sleep(2)
                await configure_generation_settings(page)
                await asyncio.sleep(2)

                generation_success = {}
                for gen_idx, (idx, row) in enumerate(to_generate):
                    prompt_text = str(row['Prompt']).strip()
                    file_name = str(row['NomeFile']).strip()

                    print(f"\n   ğŸ“ {gen_idx + 1}/{len(to_generate)}: {file_name}")

                    if not await insert_prompt_multiline(page, prompt_text):
                        print(f"   âš ï¸ Errore inserimento, salto")
                        generation_success[file_name] = False
                        continue

                    print(f"   âœ… Inserito")
                    print(f"   ğŸš€ Generate...")
                    
                    if await click_generate_button(page):
                        print(f"   âœ… Inviato")
                        generation_success[file_name] = True
                    else:
                        print(f"   âš ï¸ Errore invio")
                        generation_success[file_name] = False

                    if gen_idx < len(to_generate) - 1:
                        print(f"   â¸ï¸ Pausa {PAUSE_BETWEEN_PROMPTS}s...")
                        await asyncio.sleep(PAUSE_BETWEEN_PROMPTS)

                expected_videos = sum(1 for success in generation_success.values() if success)

                if expected_videos == 0:
                    print(f"\nâš ï¸ Nessun video da generare in questo batch\n")
                    continue

                print(f"\nâ³ Attendo che {expected_videos} video diventino pronti...")
                await wait_for_videos_ready(page, expected_videos)

                await asyncio.sleep(5)

                print(f"\nğŸ“¥ Scarico {len(to_generate)} video...\n")

                successful_downloads = 0
                for download_idx in range(len(to_generate)):
                    idx, row = to_generate[download_idx]
                    file_name = str(row['NomeFile']).strip()

                    if not generation_success.get(file_name, False):
                        print(f"   â­ï¸ {download_idx + 1}/{len(to_generate)}: {file_name} - Non generato, skip")
                        failed_prompts[file_name] = failed_prompts.get(file_name, 0) + 1
                        continue

                    # ğŸ†• Video piÃ¹ recenti sono in posizione 0 (dall'alto)
                    position = download_idx

                    print(f"   {download_idx + 1}/{len(to_generate)}: {file_name} (pos: {position})")
                    success, msg, path = await download_from_position(
                        page, file_name, download_folder, position
                    )

                    if success:
                        print(f"      âœ… {msg}\n")
                        completed_prompts.add(file_name)
                        failed_prompts.pop(file_name, None)
                        successful_downloads += 1
                    else:
                        print(f"      âŒ {msg}\n")
                        failed_prompts[file_name] = failed_prompts.get(file_name, 0) + 1

                    save_tracking(completed_prompts, failed_prompts)
                    await asyncio.sleep(3)

                print(f"âœ… BATCH {batch_num} COMPLETATO! ({successful_downloads}/{len(to_generate)} scaricati)\n")

                if i + BATCH_SIZE < total_prompts:
                    print("â¸ï¸ Pausa 15s prima del prossimo batch...")
                    await asyncio.sleep(15)

            print("\n" + "="*60)
            print("ğŸ‰ GENERAZIONE COMPLETATA!")
            print("="*60)

            videos = list(download_folder.glob("*.mp4")) + list(download_folder.glob("*.webm"))
            total_mb = sum(v.stat().st_size for v in videos) / (1024 * 1024)

            print(f"\nğŸ“Š STATISTICHE FINALI:")
            print(f"   âœ… Video scaricati: {len(videos)}/{total_prompts}")
            print(f"   ğŸ’¾ Spazio totale: {total_mb:.1f} MB")
            print(f"   âš¡ Batch processati: {batch_num}")
            print(f"   ğŸ¬ Modello usato: {MODEL.upper()}")
            print(f"   âš™ï¸ Configurazione: {DURATION}, {ASPECT_RATIO}, {RESOLUTION}")

            if failed_prompts:
                print(f"\nâš ï¸ VIDEO FALLITI: {len(failed_prompts)}")
                print("ğŸ“ Lista (salvata in failed_prompts.json):")
                for name, count in list(failed_prompts.items())[:10]:
                    print(f"   - {name}: {count} tentativi")
                if len(failed_prompts) > 10:
                    print(f"   ... e altri {len(failed_prompts) - 10}")
                print(f"\nğŸ’¡ TIP: Riesegui lo script per riprovare i falliti")

            print(f"\nğŸ“ Cartella: {download_folder}")
            print(f"ğŸ“„ Tracking: {tracking_file}")
            print(f"âŒ Fallimenti: {failed_file}\n")

        except Exception as e:
            print(f"\nâŒ ERRORE CRITICO: {e}")
            import traceback
            traceback.print_exc()
        finally:
            await browser.close()

# ESEGUI
await automate_digen_grok_batch()
